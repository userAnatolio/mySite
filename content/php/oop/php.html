<h1>Основы ООП, ведение в классы и объекты PHP</h1><br><h3>Имя свойства из метода другого объекта</h3><p><br>$user = new User(\'Иванов\', \'Иван\', \'Иванович\');<br>$prop = new Prop(\'surname\'); <span>// будем выводить значение свойства surname</span><br>echo $user->{$prop->getValue()}; <span>// выведет \'Иванов\'</span></p><br><h3>Ассоциативный массив</h3><p><br>$user = new User(\'Иванов\', \'Иван\', \'Иванович\');<br>	<br>	$props = [\'prop1\' => \'surname\', \'prop2\' => \'name\', \'prop3\' => \'patronymic\'];<br>	echo $user->{$props[\'prop1\']}; <span>// выведет \'Иванов\'</span></p><br><h3>Массив свойств</h3><p><br>Для того, чтобы такое сложное имя свойства заработало, его нужно взять в фигурные скобки, вот так:<br>	$user = new User(\'Иванов\', \'Иван\', \'Иванович\');<br>	<br>	$props = [\'surname\', \'name\', \'patronymic\'];<br>	echo $user->{$props[0]}; <span>// выведет \'Иванов\'</span></p><br><h3>Переменные названия свойств</h3><p><br>К примеру, пусть у нас есть переменная $prop, в которой лежит строка \'name\'.<br>&lt;?php<br>	$user = new User(\'Коля\', 21);<br>	<br>	$prop = \'name\';<br>	echo $user->$prop; <span>// выведет \'Коля\'</span><br>?&gt;</p><br><h3>Ошибка при вызове функции get...</h3><p><br>&lt;?php<br>	$arr = new Arr;<br>	echo $arr->getSum(); <span>// будет ошибка, если в начале создания объекта, свойства пустые.</span><br>?></p><br><h3>Начальные значения свойств в конструкторе</h3><p><br>public function __construct()<br>		{<br>			$this->prop1 = \'value1\'; <span>// начальное значение свойства</span><br>			$this->prop2 = \'value2\'; <span>// начальное значение свойства</span><br>		}</p><br><h3>Хранение объектов в массивах</h3><p><br>&lt;?php<br>	$users[] = new User(\'Коля\', 21);<br>	$users[] = new User(\'Вася\', 22);<br>	$users[] = new User(\'Петя\', 23);<br>?&gt;</p><br><h3>Работа с трейтами</h3><br><h2>Ключевое слово trait</h2><p><br>Имя трейта нужно объявлять с помощью ключевого слова trait<br>Экземпляр трейта нельзя создать.<br>Подключение осуществляется с помощью команды use.<br>	<br>class User<br>	{<br>		use Helper; <span>// подключаем трейт</span><br>			...<br>			<br>После подключения трейта в нашем классе появятся свойства и методы этого трейта.</p><br><h3>Цепочки методов</h3><p><br>$arr = new Arr;<br>echo $arr->add(1)->add(2)->add(3)->getSum(); <br>Для того, чтобы можно было написать такую цепочку, нужно, чтобы все методы, которые участвуют в цепочке возвращали $this.<br>public function add($number)<br>		{<br>			$this->numbers[] = $number;<br>			return $this; <span>// вернем ссылку сами на себя</span><br>		}</p><br><h3>Наследование классов</h3><p><br>С помощью наследования мы можем заставить наш класс Employee позаимствовать (унаследовать) методы и свойства класса User и просто дополнить их <br>своими методами и свойствами.<br>Наследование реализуется с помощью ключевого слова extends<br>class Employee extends User<br>Пусть у нас есть класс-родитель и класс-потомок. От этого потомка также могут наследовать другие классы, от его потомков другие и так далее.<br>class Student extends User</p><br><h3>Модификатор доступа protected</h3><p><br>Итак, как вы уже знаете, приватные свойства и методы не наследуются.<br>class Student extends User<br>Проблема в том, что если оставить свойство родителя приватным, то мы не сможем обратится к нему в классе-потомке - это выдаст ошибку<br>Для исправления ошибки объявим свойство как protected, а не как private:<br>protected $age;</p><br><h3>Перезапись методов родителя в классе потомке</h3><p><br>В классе-потомке разрешено сделать метод с таким же именем, как и у родителя, таким образом переопределив этот метод родителя на свой.<br>Было бы удобно, если мы метод setAge потомка мог использовать метод setAge от родителя, ведь в методе родителя расположена часть кода, которая нам <br>подходит и мы не хотим ее дублировать в методе потомка.<br>Такое можно сделать с помощью ключевого слова parent, указывающего на родителя.<br>С его помощью к переопределенному методу родителя можно обратиться так: parent::setAge(), то есть ключевое слово parent, затем два двоеточия и сам метод.<br>public function setAge($age)<br>		{<br>			<span>// Если возраст меньше или равен 25:</span><br>			if ($age &lt;= 25) {<br>				<span>// Вызываем метод родителя:</span><br>				parent::setAge($age); <span>// в родителе выполняется проверка age >= 18</span><br>			}<br>		}</p><br><h3>Перезапись конструктора родителя в потомке</h3><p><br>Если класс-потомок не имеет своего конструктора - это значит что при создании объекта класса сработает конструктор родителя:<br>	$student = new Student(\'Коля\', 19); <span>// сработает конструктор родителя</span><br>	<br>	echo $student->getName(); <span>// выведет \'Коля\'</span><br>	echo $student->getAge(); <span>// выведет 19</span><br>Все замечательно, но есть проблема: мы бы хотели при создании объекта класса Student третьим параметром передавать еще и курс, вот так:<br>$student = new Student(\'Коля\', 19, 2); <span>// это пока не работает</span><br>Самое простое, что можно сделать, это переопределить конструктор родителя своим конструктором, забрав из родителя его код и добавить в него свой кода<br>при этом необходимо исправить все свойства с private на protected, но дублирование кода родителя в классе потомке - это не очень хорошо.<br>Давайте вместо дублирования кода в конструкторе потомка вызовем конструктор родителя.<br>Вызвать конструктор родителя внутри потомка, можно с помощью parent.<br>При этом конструктор родителя первым параметром ожидает имя, а вторым - возраст, и мы должны ему их передать, вот так: parent::__construct($name, $age).<br>&lt;?php<br>	<span>// Конструктор объекта класса Student:</span><br>	public function __construct($name, $age, $course)<br>	{<br>		<span>// Вызовем конструктор родителя, передав ему два параметра:</span><br>		parent::__construct($name, $age);<br>			<br>		<span>// Запишем свойство course:<br>		$this->course = $course;<br>	}<br>?><br>Так как класс Student теперь не обращается напрямую к свойствам name и age родителя, можно их опять сделать приватными:<br>private $name;<br>private $age; <br></p><br><h3>Передача объектов по ссылке</h3><p><br>&lt;?php<br>	$user = new User(\'Коля\', 30);<br>	<br>	$test = $user; <span>// и $test, и $user ссылаются на один и тот же объект</span><br>	$test->name = \'Вася\'; <span>// поменяли переменную $test - но $user также поменялась!</span><br>	<br>	<span>// Проверим - выведем свойство name из переменной $user:<br>	echo $user->name; <span>// выведет \'Вася\'!</span><br>?></p><br><h3>Использование классов внутри других классов</h3><p><br>Бывает такое, что мы хотели бы использовать методы одного класса внутри другого, но не хотели бы наследовать от этого класса.</p>
<p><br>Логично будет не реализовывать нужные нам методы еще раз в классе 1, а воспользоваться методами которые уже есть в классе 2<br>Для этого в классе 1 создадим объект класса 2 внутри конструктора и запишем его в свойство <br>class Arr<br>	{<br>		private $nums = []; <span>// массив чисел</span><br>		private $sumHelper; <span>// сюда запишется объект класса SumHelper</span><br>		<span>// Конструктор класса:<br>		public function __construct()<br>		{<br>			<span>// Запишем объект вспомогательного класса в свойство:</span><br>			$this->sumHelper = new SumHelper;<br>		}<br>	}</p><br><h3>Передача объектов параметрами</h3><p><br>class EmployeesCollection<br>	{<br>		private $employees = [];<br>		<br>		public function add($employee)<br>		{<br>			$this->employees[] = $employee;<br>		}<br>	}</p><br><br><h3>Определение принадлежности объекта к классу</h3><p><br>Оператор instanceof. используется для определения того, является ли текущий объект экземпляром указанного класса.<br>var_dump($obj instanceof Class1);</p><br><h3>Контроль типов при работе с объектами</h3><p><br>Для этого перед именем переменной параметра следует написать имя ожидаемого класса<br>public function add(Employee $employee) <span>// Здесь можно передать только свойство, объект типа Employee, в другом случае выдаст ошибку.</span><br>		{<br>			$this->employees[] = $employee;<br>		}</p><br><h3>Статические методы</h3><p><br>При работе с классами можно делать методы, которые для своего вызова не требуют создания объекта. Такие методы называются статическими.<br>Чтобы объявить метод статическим, нужно после модификатора доступа (то есть после public, private или protected) написать ключевое слово static:<br>public static function method()<br>		{<br>			return \'!!!\';<br>		}<br>Чтобы обратиться к статическому методу, нужно написать имя класса, потом два двоеточия и имя метода, объект класса при этом создавать не надо, вот так:<br>echo Test::method(); <span>// выведет \'!!!\'</span><br></p><br><h3>Статические методы и свойства внутри класса</h3><p><br>Если вы хотите использовать статические методы внутри класса, то к ним следует обращаться не через $this->, а с помощью self::.<br>public static function getDoubleSum($a, $b)<br>		{<br>			return 2 * self::getSum($a, $b); <span>// используем другой метод</span><br>		}<br>Кроме статических методов можно также делать и статические свойства. Такие свойства также объявляются с помощью ключевого слова static:<br>Test::$property = \'test\';<br>echo Test::$property; <span>// выведет \'test\'</span><br>или внутри класса:<br>public static function getProperty()<br>		{<br>			return self::$property; <span>// прочитываем записанные данные</span><br>		}<br>Статические свойства принадлежат не какому-то объекту класса, а самому классу, хотя объекты класса и имеют доступ к этим свойствам.<br>На практике это означает то, что если у нас есть несколько объектов класса - статические свойства у них будут общие.<br>То есть, если в одном объекте поменять значение статического свойства - изменения произойдут во всех объектах.<br>$test1 = new Test; <span>// первый объект</span><br>	$test2 = new Test; <span>// второй объект</span><br>	<br>	$test1::$staticProperty = \'static\'; <span>// запишем значение, используя первый объект</span><br>	<br>	echo $test1::$staticProperty; <span>// выведет \'static\'</span><br>	echo $test2::$staticProperty; <span>// также выведет \'static\'</span><br>Если метод будет статическим. В этом случае он сможет обратиться с статическим методом и свойствам, но к обычным - нет.</p><br><h3>Абстрактные классы</h3><p><br>Абстрактные классы представляют собой классы, предназначенные для наследования от них. При этом объекты таких классов нельзя создать.<br>Для того, чтобы объявить класс абстрактным, нужно при его объявлении написать ключевое слово abstract:<br>abstract class User<br>Попытка создать объект класса User вызовет ошибку<br>А вот унаследовать от нашего класса будет можно. Сделаем класс Employee, который будет наследовать от нашего абстрактного класса User:<br>class Employee extends User<br></p><br><h3>Абстрактные методы</h3><p><br>Абстрактные классы также могут содержать абстрактные методы.<br>Такие методы не должны иметь реализации, а нужны для того, чтобы указать, что такие методы должны быть у потомков, реализация таких методов - уже задача <br>потомков.<br>Для того, чтобы объявить метод абстрактным, при его объявлении следует написать ключевое слово abstract.<br>Давайте попробуем на практике. Пусть предполагается, что все потомки класса User должны иметь метод increaseRevenue (увеличить доход).<br>Этот метод должен брать текущий доход пользователя и увеличивать его на некоторую величину, переданную параметром.<br>Сам класс User не знает, какой именно доход будет получать наследник - ведь у работника это зарплата, а у студента - стипендия.<br>Поэтому каждый потомок будет реализовывать этот метод по-своему.<br>Таким образом вы, или другой программист, работающий с вашим кодом, никак не сможете забыть реализовать нужный метод в потомке.<br><span>// Абстрактный метод без тела:<br>		abstract public function increaseRevenue($value);<br>		<br>При наследовании от абстрактного класса, все методы, помеченные абстрактными в родительском классе, должны быть определены в дочернем классе.<br>При этом область видимости этих методов должна совпадать или быть менее строгой. Что значит менее строгой: например, если абстрактный метод объявлен как <br>protected, то реализация этого метода должна быть protected или public, но не private.<br>Объявления методов также должны совпадать: количество обязательных параметром должно быть одинаковым.<br>Однако класс-потомок может добавлять необязательные параметры, которые не были указанны при объявлении метода в родителе.</p><br><h3>Интерфейсы</h3><p><br>Фактически ваш родительский класс описывает интерфейс потомков, то есть набор их публичных методов, обязательных для реализации.<br>Пусть мы хотим физически запретить делать в родителе иные методы, кроме абстрактных публичных.<br>В PHP для этого вместо абстрактных классов можно использовать интерфейсы.<br>Интерфейсы представляют собой классы, у которых все методы являются публичными и не имеющими реализации. Код методов должны реализовывать <br>классы-потомки интерфейсов.<br>Интерфейсы объявляются так же, как и обычные классы, но используя ключевое слово interface вместо слова class.<br>Вместо слова extends следует использовать ключевое слово implements<br>Замечание: нельзя создать объект интерфейса.<br>Еще замечание: все методы интерфейса не должны иметь реализации.<br>Еще замечание: все методы интерфейса должны быть объявлены как public.<br>Кроме того, у интерфейса могут быть только методы, но не свойства.<br>Нельзя также сделать интерфейс и класс с одним и тем же названием.<br>Общепринято в таком случае название интерфейса начать с маленькой буквы i, чтобы показать, что это интерфейс, а не класс.<br>При описании методов в интерфейсах необходимо указывать не только имена самих методов, но и принимаемые ими параметры.</p><br><h3>Объявление конструктора в интерфейсе</h3><p><br>В интерфейсе также можно объявить конструктор класса.<br>interface iRectangle<br>	{<br>		public function __construct($a, $b); <span>// конструктор с двумя параметрами</span><br>		public function getSquare(); <span>// нахождение площади</span><br>		public function getPerimeter(); <span>// нахождение периметра</span><br>	}<br>Что нам дало объявление конструктора в интерфейсе? Во-первых, мы не забудем реализовать конструктор в классе.<br>Во-вторых, интерфейс явно указывает, что конструктор класса должен принимать два параметра: ни больше, ни меньше. Это также предохранит нас от <br>случайной ошибк</p><br><h3>Наследование интерфейсов друг от друга</h3><p><br>Интерфейсы, так же, как и классы, могут наследовать друг от друга с помощью оператора extends.<br>Давайте сделаем так, чтобы интерфейс iRectangle наследовал методы интерфейса Figure:<br>interface iRectangle extends Figure<br>	{<br>		public function __construct($a, $b);<br>	}<br></p><br><h3>Интерфейсы и instanceof</h3><p><br>Оператор instanceof при работе с интерфейсами работает так же, как и при наследовании.<br>$quadrate = new Quadrate;<br>var_dump($quadrate instanceof Quadrate);</p><br><h3>Несколько интерфейсов</h3><p><br>В PHP нет множественного наследования - каждый класс может иметь только одного родителя.<br>С интерфейсами дело, однако, обстоит по другому: каждый класс может реализовывать любое количество интерфейсов.<br>Для этого имена интерфейсов нужно перечислить через запятую после ключевого слова implements<br>class Quadrate implements Figure, Tetragon</p><br><h3>Наследование от класса и реализация интерфейса</h3><p><br>Класс может наследовать от другого класса и при этом реализовывать какой-то интерфейс.<br>class Programmer extends Employee implements iProgrammer<br>Получится, что наш класс Pogrammer унаследует от класса Employee методы __construct, getName() и getSalary(), а методы addLang и getLangs нам придется <br>реализовать</p><br><br><h1>Пространства имен PHP</h1><h3>namespace</h3><p><br>Только выражение declare может находиться перед namespace<br><br>namespace MyProject;<br><br>Так же как файлы и каталоги, пространства имен PHP позволяют создавать иерархию имен<br><br>namespace MyProject\Sub\Level;<br><br>Описание нескольких пространств имен<br><br>namespace My;<br>class C {  }<br>function con() {   }<br><br>namespace Another;<br>class C {  }<br>function con() {   }<br><br>Данный синтаксис не рекомендуется для комбинирования пространств имен в одном файле.<br><br>namespace My{<br>class C {  }<br>function con() {   }<br>}<br><br>namespace Another{<br>class C {  }<br>function con() {   }<br>}<br><br>Описание глобального и обычного пространства имен из одного файла:<br><br>namespace MyProject<br>{<br>...<br>}<br><br>namespace {       <span>// глобальный код</span><br>session_start();<br>MyProject\func();<br>echo MyProject\start();<br>}<br><br>Имя класса может быть указано тремя способами:<br>/* Неполные имена */<br>foo();<br>/* Полные имена */<br>subnamespace\foo();<br>/* Абсолютные имена */<br>\Foo\Bar\foo::staticmethod();<br><br>Значение константы __NAMESPACE__ - это строка, которая содержит имя текущего пространства имен. <br>namespace MyProj;<br>echo \'"\', __NAMESPACE__, \'"\'; <span>// выводит "MyProj"</span><br><br>создание псевдонима имени с помощью оператора use<br>use My\Full\Classname as Another;<br><br>Ключевое слово use должно быть указано в самом начале файла (в глобальной области) или внутри объявления пространства имен. <br>Это необходимо потому, что импорт выполняется во время компиляции, а не во время исполнения, поэтому оно не может быть заключено в блок.</p>