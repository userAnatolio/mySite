<h1>Pointer C++</h1>
<h2>strlen()</h2>
//<h3>Заголовок &lt;cstring&gt;</h3>
<pre>
Указатель — это переменная, значением которой является адрес памяти.
Тип указателя должен соответствовать типу переменной, на которую он указывает
ptr — это то же самое, что и &value;
*ptr обрабатывается так же, как и value.
Поскольку *ptr обрабатывается так же, как и value, то мы можем присваивать ему значения так, как если бы это была бы обычная переменная
Разыменование указателя, значением которого является мусор, приведет к сбою в вашей программе.

int main()
{
    int a = 7;
    cout &lt;&lt; a; // выводим значение переменной a
    cout &lt;&lt; &a; // выводим адрес памяти переменной a
	cout &lt;&lt; &a &lt;&lt; '\n'; // выводим адрес памяти переменной a
	cout &lt;&lt; *&a &lt;&lt; '\n'; /// выводим значение ячейки памяти переменной a
	int *ptr = &a; // инициализируем ptr адресом значения переменной
	cout &lt;&lt; &a &lt;&lt; '\n'; // выводим адрес значения переменной a
	cout &lt;&lt; ptr &lt;&lt; '\n'; // выводим адрес, который хранит ptr
	int *ptr = 7; // не является допустимым
	double *dPtr = 0x0012FF7C; // C++ также не позволит вам напрямую присваивать адреса памяти указателю, рассматривается как присваивание целочисленного литерала
	int b = 5; //После присваивания одного значения указателю, ему можно присвоить и другое
	ptr = &b; // ptr теперь указывает на b
 
    return 0;
}

Стоит отметить, что оператор адреса (&) не возвращает адрес своего операнда в качестве литерала. Вместо этого он возвращает указатель, содержащий адрес операнда, 
тип которого получен из аргумента (например, адрес переменной типа int передастся как адрес указателя на значение типа int).

Указатели полезны в следующих случаях:
1. Массивы реализованы с помощью указателей. Они могут использоваться для итерации по массиву.

2. Они являются единственным способом динамического распределения памяти в C++ . Это, безусловно, самый распространенный вариант использования указателей.

3. Они могут использоваться для передачи большого количества данных в функцию без копирования этих данных.

4. Они могут использоваться для передачи одной функции в качестве параметра другой функции.

5. Они используются для достижения полиморфизма при работе с наследованием.

6. Они могут использоваться для представления одной структуры/класса в другой структуре/классе, формируя, таким образом, целые цепочки.

<i>Данный материал взят с сайта ravesli.com/urok-80</i>
</pre>