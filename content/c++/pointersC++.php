<h1>Pointer C++</h1>
<pre>
Указатель — это переменная, значением которой является адрес памяти.
Тип указателя должен соответствовать типу переменной, на которую он указывает
ptr — это то же самое, что и &value;
*ptr обрабатывается так же, как и value.
Поскольку *ptr обрабатывается так же, как и value, то мы можем присваивать ему значения так, как если бы это была бы обычная переменная
Разыменование указателя, значением которого является мусор, приведет к сбою в вашей программе.

int main()
{
    int a = 7;
    cout &lt;&lt; a; // выводим значение переменной a
    cout &lt;&lt; &a; // выводим адрес памяти переменной a
	cout &lt;&lt; &a &lt;&lt; '\n'; // выводим адрес памяти переменной a
	cout &lt;&lt; *&a &lt;&lt; '\n'; /// выводим значение ячейки памяти переменной a
	int *ptr = &a; // инициализируем ptr адресом значения переменной
	cout &lt;&lt; &a &lt;&lt; '\n'; // выводим адрес значения переменной a
	cout &lt;&lt; ptr &lt;&lt; '\n'; // выводим адрес, который хранит ptr
	int *ptr = 7; // не является допустимым
	double *dPtr = 0x0012FF7C; // C++ также не позволит вам напрямую присваивать адреса памяти указателю, рассматривается как присваивание целочисленного литерала
	int b = 5; //После присваивания одного значения указателю, ему можно присвоить и другое
	ptr = &b; // ptr теперь указывает на b
 
    return 0;
}

Стоит отметить, что оператор адреса (&) не возвращает адрес своего операнда в качестве литерала. Вместо этого он возвращает указатель, содержащий адрес операнда, 
тип которого получен из аргумента (например, адрес переменной типа int передастся как адрес указателя на значение типа int).

Указатели полезны в следующих случаях:
1. Массивы реализованы с помощью указателей. Они могут использоваться для итерации по массиву.

2. Они являются единственным способом динамического распределения памяти в C++ . Это, безусловно, самый распространенный вариант использования указателей.

3. Они могут использоваться для передачи большого количества данных в функцию без копирования этих данных.

4. Они могут использоваться для передачи одной функции в качестве параметра другой функции.

5. Они используются для достижения полиморфизма при работе с наследованием.

6. Они могут использоваться для представления одной структуры/класса в другой структуре/классе, формируя, таким образом, целые цепочки.

Указатель может хранить: значение null. Указатель, содержащий значение null, называется нулевым указателем.

int *ptr(0);  // ptr - теперь нулевой указатель
int *ptr1; // ptr1 - неинициализирован
ptr1 = 0; // ptr1 - теперь нулевой указатель
Поскольку значением нулевого указателя является нуль, то это можно использовать внутри условного ветвления для проверки того, является ли указатель нулевым или нет:
double *ptr(0);
 
if (ptr)
    cout &lt;&lt; "ptr is pointing to a double value.";
else
    cout &lt;&lt; "ptr is a null pointer.";

С разыменованием нулевого указателя получим сбой.
В языке C (но не C++) определен специальный макрос препроцессора с именем NULL, который #defined как значение 0.
nullptr — это и ключевое слово, и константа r-value.
int *ptr = nullptr; // примечание: ptr по прежнему остается указателем типа int, просто со значением null (0)
nullptr также может использоваться для вызова функции, в качестве аргумента-литерала:
int main()
{
    doAnything(nullptr); // теперь уже аргумент является точно нулевым указателем, а не целочисленным значением
 
    return 0;
}
В C++11 добавили новый тип — std::nullptr_t (находится в заголовочном файле &lt;cstddef&gt;). std::nullptr_t может иметь только одно значение: nullptr! 

#include &lt;cstddef> // для std::nullptr_t
 
void doAnything(std::nullptr_t ptr)
{
    std::cout &lt;&lt; "in doAnything()\n";
}
 
int main()
{
    doAnything(nullptr); // вызов функции doAnything с аргументом типа std::nullptr_t
 
    return 0;
}


<i>Данный материал взят с сайта ravesli.com/urok-80</i>
</pre>

<h2>Указатели и массивы</h2>
<pre>
int array[4] = { 5, 8, 6, 4 };
Переменная array содержит адрес первого элемента в массиве, как если бы это был указатель
int main()
{
	int array[4] = { 5, 8, 6, 4 };
	cout &lt;&lt;  array &lt;&lt; '\n'; // выводим значение массива (переменной array)
	cout &lt;&lt;  &array[0] &lt;&lt; '\n'; // выводим адрес первого элемента массива
	return 0;
}
Результат:
address: 00AFFCDC
address: 00AFFCDC
Ошибка думать, что переменная array и указатель на array  — идентичны.
cout &lt;&lt; typeid(array).name() &lt;&lt; '\n'; // выведет int [4]
cout &lt;&lt; typeid(&array[0]).name() &lt;&lt; '\n'; // выведет int *
</pre>

<h2>Передача массива параметром в функцию</h2>
<pre>
следующие два объявления функции идентичны:
void printSize(int array[]);
void printSize(int *array);
рекомендуем использовать синтаксис указателя, поскольку он дает понять, что параметр будет обрабатываться как указатель, 
а не как фиксированный массив, и определенные операции, такие как sizeof(), будут выполняться с параметром, как с указателем 
(а не как с фиксированным массивом).
/ параметр ptr содержит копию адреса массива
void changeArray(int *ptr)
{
    *ptr = 5; // поэтому изменение элемента массива приведет к изменениям фактического массива
}
При вызове changeArray(), массив распадется на указатель, а значение этого указателя (адрес памяти первого элемента в массиве) скопируется 
в параметр ptr функции changeArray(). Хотя значение ptr в функции является копией адреса массива, ptr все равно указывает на фактический массив (а не на копию!). Следовательно, при разыменовании ptr, разыменовывается и фактический массив!
В заключение стоит отметить, что массивы, которые являются частью структур или классов, не распадаются, когда вся структура или класс передаются в функцию.
</pre>