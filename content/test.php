<div id="htaccess">
<h1>Файл .htaccess</h1>
<p>
В Linux его не будет видно в обыном каталоге, так как у этого файл существует без имени и имеет только расширение<br>
Что показать видимость этого файла в linux необходимо нажать сочетание ctrl+H.<br>
Первая настройка:<br>
RewriteEngine/ On или Of
позволит включить сам файл или выключить(временно).<br>
Вторая настройка:<br>
RewriteBase /<br>
обязательна или необязательна, лучше пускай будет<br>
Дальше идут команды или так называемые диррективы<br>
Redirect /index.php /test.php<br>
дериктива Redirect позволяет делать перенаправления из одного файла в другой.<br>
Следующая дирректива RewriteRule она работает аналогично Redirect, но есть существенные отличия:<br>
В этой дериктиве не нужно разделять два файла слэшем, достаточно просто пробела, во вторых, если я правильно понял,<br>
эта директива работает из любого каталога, не обязательно использовать корневой каталог.<br>
Ну и самое важное, при редиректе с первого файла, на другой, в адресной строке остается адрес первого каталога, об <br>
этом знает только админ сайта, обычный пользователь этого не заметит.<br>
Здесь я делаю редирект всех файлов в корневой каталог, там у меня находится файл index.php<br>
RewriteRule / /<br>
Если мой index.php находится в папке mySite, тогда я сделаю так:<br>
RewriteRule / mySite/<br>
Сделаю редирект всех запросов из папки mySite к файлу index.php<br>
RewriteRule mySite/ index.php<br>
В директиве RewriteRule можно использовать регулярные выражение и даже карманы:<br>
Сделаю редирект всех файлов .html на главную страницу корневого каталога index.php<br>
RewriteRule /.*\.html index.php<br>
Выполняю редирект всех файлов, заканчивающихся на .html на такие же файлы, но с расширением .php.<br>
RewriteRule /.*\.html index.php<br>
Выполняю редирект всех файлов, заканчивающихся на .html на такие же файлы, но с расширением .php, использую карман и отрицание(!):<br>
RewriteRule /(.*)\.html 1$.php<br>
Выполняю редирект всех запросов к своему сайту на такие же запросы, но на сайте http://site.com.<br>
RewriteRule /(.*)\.php http://site.com/$1\.php<br>
Можно также отправлять GET параметры<br>
RewriteRule /(.*)\.php mySite/index.php?num=7<br>
Есть еще директива RedirectMatch, она специально предназначена для работы с регулярными выражениями.<br>
Следующая не менее полезная директива RewriteCond:<br>
В директиве хранится переменная, которая содержит условие, условие пишется после  переменной %{REQUEST_URI}.<br>
Исходя из условия будут передаваться только те файлы, которые попадают под это условие.<br>
Можно инициализировать несколько переменных и использовать их одновременно с помощью флага [OR] (или).<br>
RewriteCond %{REQUEST_URI} .css$ [OR]<br>
RewriteCond %{REQUEST_URI} .css$ [OR]<br>
RewriteCond %{REQUEST_URI} .js$ [OR]<br>
RewriteCond %{REQUEST_URI} .php$<br>
После переменной пишем директиву RewriteRule.<br>
Оператором .+ мы говорим, что нужно использовать все переменные, которые прописаны выше.<br>
RewriteRule .+ index.php<br>
Благодаря диррективе RewriteCond я могу использовать несколько условий, а не придумывать сложную регулярку.<br>
RewriteCond %{REQUEST__FILENAME} отличается названием переменной {REQUEST__FILENAME}, после нее мы прописываем специальные флаги<br>
Вот некоторые из них:<br>
-d будет перенаправлять все дирректории, но не папки, т.е. /dir/ или /dir/folder/, но не /dir/test.php<br>
-f Только файлы<br>
!-f несуществующие файлы<br>
-s непустые файлы<br>
Все эти флаги, тоже своего рода условие, исходя из которого, будет осуществляться редирект.<br>
После этих файлов также можно писать [OR] использовать несколько переменных.<br>
Если {REQUEST_URI} и {REQUEST__FILENAME} используются вместе, то логический [OR] использовать не нужно, хотя если честно здесь я<br>
запутался, потому, что у меня две переменные типа {REQUEST_FILENAME} работали как с [OR], так и без него.<br>
RewriteCond %{REQUEST_URI} .html$<br>
RewriteCond %{REQUEST_FILENAME} -f <br>
RewriteRule ^ index.php [L]<br>
ВАЖНО ЗНАТЬ
Чтобы достать содержимое кармана RewriteCond и передать его в GET параметр необходимо использовать знак % вместо $<br>
RewriteCond %{REQUEST_URI} !index.php<br>
RewriteCond %{REQUEST_URI} (.*+)<br>
RewriteRule (.+) index.php?get1=%1<br>
При этом использование первой директивы RewriteCond %{REQUEST_URI} !index.php необходимо<br>
 для отрицание повторного цикла, будто бы условие уже выполнилось<br>
Тогда в карман будет передаваться адрес, с которого был осуществлен переход<br>
Чтобы игнорировать регистр в адресно строке необходимо использовать флаг [NC]<br>
Если флагов несколько, тогда все флаги перечисляются через запятую [NC, L]<br>

Если страница не существует, сервер автоматически выводит стандартную страницу 404 <br>
Вместо стандртной страницы можно использовать свою страницу 404:<br>
ErrorDocument 404 /content/notFind.php<br>
Где /content/notFind.php это путь к файлу<br>
Если при этом не использовать слеш, то /content/notFind.php будет рассматривать в браузере просто как текст<br>
Если положить в папку с файлом файл .htaccess  и прописать в нем следующее:<br>
deny from all<br>
Тогда доступ к этой папке не будет доступен напрямую(из строки браузера, а только через include.<br>
</p>
</div>